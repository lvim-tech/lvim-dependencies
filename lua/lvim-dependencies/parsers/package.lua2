local api = vim.api
local fn = vim.fn
local schedule = vim.schedule
local defer_fn = vim.defer_fn
local split = vim.split
local table_concat = table.concat
local tostring = tostring

local decoder = require("lvim-dependencies.libs.decoder")
local state = require("lvim-dependencies.state")
local utils = require("lvim-dependencies.utils")
local clean_version = utils.clean_version

local M = {}

-- Try parse lock files and extract resolved versions (pnpm-lock.yaml / package-lock.json)
local function parse_lock_file_from_content(content)
	if not content or content == "" then
		return {}
	end

	-- pnpm-lock.yaml detection
	if content:match("^lockfileVersion:") or content:match("\nlockfileVersion:") then
		local versions = {}
		local lines = split(content, "\n")

		local function normalize_val(v)
			v = tostring(v or ""):gsub("^%s*['\"]", ""):gsub("['\"]%s*$", "")
			if v == "" then
				return nil
			end
			-- keep leading semver-ish part if present (handles 1.2.3(foo@bar))
			return v:match("^([0-9]+%.[0-9]+%.[0-9]+[%w%-%._]*)") or v
		end

		local function match_pkg_key(line, indent_spaces)
			-- match either:
			--   <indent>name:
			--   <indent>"@scope/name":
			--   <indent>'@scope/name':
			local indent = string.rep("%s", indent_spaces)
			return line:match("^" .. indent .. '"([%w%-%_@/%.]+)"%s*:%s*$')
				or line:match("^" .. indent .. "'([%w%-%_@/%.]+)'%s*:%s*$")
				or line:match("^" .. indent .. "([%w%-%_@/%.]+):%s*$")
		end

		local function match_field(line, indent_spaces, field)
			local indent = string.rep("%s", indent_spaces)
			return line:match("^" .. indent .. field .. ":%s*(.+)%s*$")
		end

		-- ---------------------------
		-- Fix 2: parse resolved versions from snapshots:/packages:
		-- ---------------------------
		-- pnpm v9+: snapshots:
		--   '@babel/core@8.0.0-rc.1':
		-- pnpm older: packages:
		--   /@babel/core@8.0.0-rc.1:
		--
		-- We extract:
		--   versions["@babel/core"] = "8.0.0-rc.1"
		--
		-- NOTE: snapshot keys can include parentheses:
		--   'foo@1.2.3(bar@4.5.6)'
		-- We only keep leading version segment.
		local mode = "none" -- "none" | "snapshots" | "packages"
		for _, line in ipairs(lines) do
			if line:match("^snapshots:%s*$") then
				mode = "snapshots"
			elseif line:match("^packages:%s*$") then
				mode = "packages"
			elseif line:match("^[^%s]") then
				-- leaving section on next top-level key
				if not line:match("^snapshots:%s*$") and not line:match("^packages:%s*$") then
					mode = "none"
				end
			end

			if mode ~= "none" then
				-- snapshots keys examples (2 space indent):
				--   '@babel/core@8.0.0-rc.1':
				--   "@babel/core@8.0.0-rc.1":
				--   copy-webpack-plugin@13.0.1(webpack@5.0.0):
				local key = line:match("^%s%s'([^']+)'%s*:%s*$")
					or line:match('^%s%s"([^"]+)"%s*:%s*$')
					or line:match("^%s%s([^%s].-)%s*:%s*$")

				if key and key ~= "" then
					-- packages: keys might start with "/" (older pnpm): "/name@1.2.3"
					key = key:gsub("^/", "")

					-- Derive name + version by splitting at the last "@<version>" segment.
					-- Works for:
					--   name@1.2.3
					--   @scope/name@1.2.3
					--   @scope/name@1.2.3(whatever@x)
					local name, ver = key:match("^(.+)@(%d+%.%d+%.%d+[^%s%(]*)")
					if not ver then
						name, ver = key:match("^(.+)@(%d+%.%d+[^%s%(]*)")
					end

					if name and ver then
						-- cleanup any trailing decoration for name
						name = name:gsub("%s*$", "")
						versions[name] = normalize_val(ver) or versions[name]
					end
				end
			end
		end

		-- ---------------------------
		-- Supplement: importers/top-level deps presence (and fallback if snapshots missing)
		-- ---------------------------
		-- If snapshots/packages parsing produced no data (some pnpm edge cases),
		-- we fallback to importers/top-level version fields as before.
		if vim.tbl_isempty(versions) then
			-- pnpm layouts:
			-- 1) top-level dependencies/devDependencies
			-- 2) importers: .: dependencies/devDependencies (pnpm v9+ / monorepos)
			local imode = "none" -- "top" | "importers"
			local in_importer_dot = false
			local in_deps = false
			local in_dev = false
			local current = nil

			local function reset_sections()
				in_deps = false
				in_dev = false
				current = nil
			end

			for _, line in ipairs(lines) do
				-- detect top-level blocks / mode switches
				if line:match("^dependencies:%s*$") then
					imode = "top"
					in_deps = true
					in_dev = false
					current = nil
				elseif line:match("^devDependencies:%s*$") then
					imode = "top"
					in_deps = false
					in_dev = true
					current = nil
				elseif line:match("^importers:%s*$") then
					imode = "importers"
					in_importer_dot = false
					reset_sections()
				end

				-- -----------------
				-- imode == top
				-- -----------------
				if imode == "top" then
					-- leave when another top-level key starts
					if
						line:match("^[^%s]")
						and not line:match("^dependencies:%s*$")
						and not line:match("^devDependencies:%s*$")
					then
						reset_sections()
					end

					if in_deps or in_dev then
						-- keys at indent=2
						local pkg = match_pkg_key(line, 2)
						if pkg then
							current = pkg
						end

						if current then
							-- fields at indent=4
							local ver = match_field(line, 4, "version")
							if ver then
								versions[current] = normalize_val(ver) or versions[current]
								current = nil
							else
								local spec = match_field(line, 4, "specifier")
								if spec then
									-- fallback: at least mark it as present in lock
									versions[current] = normalize_val(spec) or versions[current]
									current = nil
								end
							end
						end
					end

				-- -----------------
				-- imode == importers
				-- -----------------
				elseif imode == "importers" then
					-- importer header can be: "  .:" or "  \".\":"
					if line:match("^%s%s%.:%s*$") or line:match('^%s%s"%."%s*:%s*$') then
						in_importer_dot = true
						reset_sections()
					elseif
						line:match("^%s%s[^%s].-:%s*$")
						and not (line:match("^%s%s%.:%s*$") or line:match('^%s%s"%."%s*:%s*$'))
					then
						-- entering another importer (not ".")
						in_importer_dot = false
						reset_sections()
					end

					if in_importer_dot then
						-- inside importer ".", deps blocks at indent=4
						if line:match("^%s%s%s%sdependencies:%s*$") then
							in_deps = true
							in_dev = false
							current = nil
						elseif line:match("^%s%s%s%sdevDependencies:%s*$") then
							in_deps = false
							in_dev = true
							current = nil
						elseif
							line:match("^%s%s%s%s[^%s].-:%s*$")
							and not line:match("^%s%s%s%s(dependencies|devDependencies):%s*$")
						then
							-- leaving deps blocks at importer level when another 4-space key starts
							reset_sections()
						end

						if in_deps or in_dev then
							-- package keys at indent=6
							local pkg = match_pkg_key(line, 6)
							if pkg then
								current = pkg
							end

							if current then
								-- fields at indent=8
								local ver = match_field(line, 8, "version")
								if ver then
									versions[current] = normalize_val(ver) or versions[current]
									current = nil
								else
									local spec = match_field(line, 8, "specifier")
									if spec then
										-- fallback: at least mark it as present in lock
										versions[current] = normalize_val(spec) or versions[current]
										current = nil
									end
								end
							end
						end
					end
				end
			end
		end

		return versions
	end

	-- JSON lock (package-lock.json / npm-shrinkwrap.json)
	local ok, parsed = pcall(decoder.parse_json, content)
	if not ok or type(parsed) ~= "table" then
		return {}
	end

	local versions = {}

	-- npm v7+ has packages table
	if parsed.packages and type(parsed.packages) == "table" then
		for pkg_path, info in pairs(parsed.packages) do
			if type(info) == "table" and info.version then
				local name = pkg_path:match("node_modules/([^/]+)$") or pkg_path:gsub("^node_modules/", "")
				if name and name ~= "" then
					versions[name] = tostring(info.version)
				end
			end
		end
	end

	-- npm v5/v6 dependencies
	if parsed.dependencies and type(parsed.dependencies) == "table" then
		for name, info in pairs(parsed.dependencies) do
			if info and type(info) == "table" and info.version then
				versions[name] = tostring(info.version)
			end
		end
	end

	return versions
end

-- Fallback loose parser for package.json-like content (handles JS comments)
local function parse_package_fallback_lines(lines)
	if not lines or type(lines) ~= "table" then
		return {}, {}
	end

	local function strip_comments_and_trim(s)
		if not s then
			return nil
		end
		-- remove line comments and simple block comments, then trim and drop trailing commas
		local t = s:gsub("//.*$", ""):gsub("/%*.-%*/", ""):gsub(",%s*$", ""):match("^%s*(.-)%s*$")
		if t == "" then
			return nil
		end
		return t
	end

	local function collect_block(start_idx)
		local tbl = {}
		local brace_level = 0
		local started = false
		local last_idx = start_idx

		-- scan until block end (no artificial limit)
		for i = start_idx, #lines do
			local raw_line = lines[i]
			local line = strip_comments_and_trim(raw_line)
			if not line then
				last_idx = i
			else
				-- detect object start
				if not started and line:find("{", 1, true) then
					started = true
				end

				-- update brace level
				for c in line:gmatch(".") do
					if c == "{" then
						brace_level = brace_level + 1
					elseif c == "}" then
						brace_level = brace_level - 1
					end
				end

				-- capture simple "name": "version" entries (handles quoted keys)
				for name, ver in line:gmatch([[%s*["']?([%w%-%_@/%.]+)["']?%s*:%s*["']([^"']+)["']%s*,?]]) do
					if name and ver then
						tbl[name] = ver
					end
				end

				last_idx = i
				if started and brace_level <= 0 then
					break
				end
			end
		end

		return tbl, last_idx
	end

	local deps = {}
	local dev_deps = {}
	local i = 1
	while i <= #lines do
		local raw = lines[i]
		if raw ~= nil then
			local lower = raw:lower()
			if lower:match('%s*"?dependencies"?%s*:') then
				local parsed, last = collect_block(i)
				for k, v in pairs(parsed) do
					deps[k] = { raw = v, current = (clean_version(v) or tostring(v)) }
				end
				if last and last > i then
					i = last
				end
			elseif lower:match('%s*"?devdependencies"?%s*:') or lower:match('%s*"?dev%-dependencies"?%s*:') then
				local parsed, last = collect_block(i)
				for k, v in pairs(parsed) do
					dev_deps[k] = { raw = v, current = (clean_version(v) or tostring(v)) }
				end
				if last and last > i then
					i = last
				end
			end
		end
		i = i + 1
	end

	return deps, dev_deps
end

-- Use JSON decoder when possible; fallback to loose line parser
local function parse_with_decoder(content, lines)
	local ok, parsed = pcall(decoder.parse_json, content)
	if ok and type(parsed) == "table" then
		local deps = {}
		local dev_deps = {}
		local optional_deps = {}
		local peer_deps = {}
		local overrides = {}

		local raw_deps = parsed.dependencies or parsed.deps
		local raw_dev = parsed.devDependencies or parsed.dev_dependencies
		local raw_opt = parsed.optionalDependencies or parsed.optional_dependencies
		local raw_peer = parsed.peerDependencies or parsed.peer_dependencies
		local raw_overrides = parsed.overrides or parsed.dependency_overrides

		local function collect_from_raw(raw_tbl, out_tbl)
			if raw_tbl and type(raw_tbl) == "table" then
				for name, val in pairs(raw_tbl) do
					local raw, has = utils.normalize_entry_val(val)
					local cur = has and (clean_version(raw) or tostring(raw)) or nil
					out_tbl[name] = { raw = raw, current = cur }
				end
			end
		end

		collect_from_raw(raw_deps, deps)
		collect_from_raw(raw_dev, dev_deps)
		collect_from_raw(raw_opt, optional_deps)
		collect_from_raw(raw_peer, peer_deps)
		collect_from_raw(raw_overrides, overrides)

		return {
			dependencies = deps,
			devDependencies = dev_deps,
			optionalDependencies = optional_deps,
			peerDependencies = peer_deps,
			overrides = overrides,
		}
	end

	local fb_deps, fb_dev = parse_package_fallback_lines(lines or split(content, "\n"))
	return {
		dependencies = fb_deps or {},
		devDependencies = fb_dev or {},
		optionalDependencies = {},
		peerDependencies = {},
		overrides = {},
	}
end

local function map_source_to_scope(source)
	if source == "dependencies" then
		return "dependencies"
	end
	if source == "dev_dependencies" then
		return "devDependencies"
	end
	if source == "optional_dependencies" then
		return "optionalDependencies"
	end
	if source == "peer_dependencies" then
		return "peerDependencies"
	end
	if source == "overrides" then
		return "overrides"
	end
	return "dependencies"
end

local function do_parse_and_update(bufnr, parsed_tables, buffer_lines, content)
	if not api.nvim_buf_is_valid(bufnr) then
		return
	end
	parsed_tables = parsed_tables or {}

	local deps = parsed_tables.dependencies or {}
	local dev_deps = parsed_tables.devDependencies or {}
	local optional_deps = parsed_tables.optionalDependencies or {}
	local peer_deps = parsed_tables.peerDependencies or {}
	local overrides = parsed_tables.overrides or {}

	local installed_dependencies = {}
	local invalid_dependencies = {}

	local function add(tbl, source)
		for name, info in pairs(tbl or {}) do
			if installed_dependencies[name] then
				invalid_dependencies[name] = { diagnostic = "DUPLICATED" }
			end
			installed_dependencies[name] = {
				current = info.current,
				raw = info.raw,
				_source = source,
			}
		end
	end

	add(deps, "dependencies")
	add(dev_deps, "dev_dependencies")
	add(optional_deps, "optional_dependencies")
	add(peer_deps, "peer_dependencies")
	add(overrides, "overrides")

	schedule(function()
		if not api.nvim_buf_is_valid(bufnr) then
			return
		end

		-- save buffer meta
		if state.save_buffer then
			state.save_buffer(bufnr, "package", api.nvim_buf_get_name(bufnr), buffer_lines)
		end

		-- ensure + clear manifest container
		if state.ensure_manifest then
			state.ensure_manifest("package")
		end
		if state.clear_manifest then
			state.clear_manifest("package")
		end

		-- prefer per-dependency API to capture scopes; fallback to bulk set_installed
		local used_add = false
		if state.add_installed_dependency then
			used_add = true
			for name, info in pairs(installed_dependencies) do
				local scope = map_source_to_scope(info._source or "dependencies")
				state.add_installed_dependency("package", name, info.current, scope)
			end
		end

		if not used_add then
			local bulk = {}
			for name, info in pairs(installed_dependencies) do
				local scope = map_source_to_scope(info._source or "dependencies")
				bulk[name] = { current = info.current, scopes = { [scope] = true } }
			end
			if state.set_installed then
				state.set_installed("package", bulk)
			end
		end

		-- invalids and outdated placeholder
		if state.set_invalid then
			state.set_invalid("package", invalid_dependencies)
		end
		if state.set_outdated then
			state.set_outdated("package", state.get_dependencies("package").outdated or {})
		end

		-- update buffer cached lines/last run metadata
		if state.update_buffer_lines then
			state.update_buffer_lines(bufnr, buffer_lines)
		end
		if state.update_last_run then
			state.update_last_run(bufnr)
		end

		-- attach last parsed snapshot to buffer for caching
		state.buffers = state.buffers or {}
		state.buffers[bufnr] = state.buffers[bufnr] or {}
		state.buffers[bufnr].last_package_parsed =
			{ installed = installed_dependencies, invalid = invalid_dependencies }
		state.buffers[bufnr].parse_scheduled = false

		-- compute and store hash
		state.buffers[bufnr].last_package_hash = fn.sha256(content)
		state.buffers[bufnr].last_changedtick = api.nvim_buf_get_changedtick(bufnr)

		-- render virtual text and trigger checker
		require("lvim-dependencies.ui.virtual_text").display(bufnr, "package")
		require("lvim-dependencies.actions.check_manifests").check_manifest_outdated(bufnr, "package")
	end)
end

M.parse_buffer = function(bufnr)
	bufnr = bufnr or fn.bufnr()
	if bufnr == -1 then
		return nil
	end

	state.buffers = state.buffers or {}
	state.buffers[bufnr] = state.buffers[bufnr] or {}

	local buf_changedtick = api.nvim_buf_get_changedtick(bufnr)
	if state.buffers[bufnr].last_changedtick and state.buffers[bufnr].last_changedtick == buf_changedtick then
		if state.buffers[bufnr].last_package_parsed then
			defer_fn(function()
				require("lvim-dependencies.ui.virtual_text").display(bufnr, "package")
			end, 10)
			return state.buffers[bufnr].last_package_parsed
		end
	end

	local buffer_lines = api.nvim_buf_get_lines(bufnr, 0, -1, false)
	local content = table_concat(buffer_lines, "\n")

	-- quick hash check
	local current_hash = fn.sha256(content)
	if state.buffers[bufnr].last_package_hash and state.buffers[bufnr].last_package_hash == current_hash then
		state.buffers[bufnr].last_changedtick = buf_changedtick
		if state.buffers[bufnr].last_package_parsed then
			defer_fn(function()
				require("lvim-dependencies.ui.virtual_text").display(bufnr, "package")
			end, 10)
			return state.buffers[bufnr].last_package_parsed
		end
	end

	if state.buffers[bufnr].parse_scheduled then
		return state.buffers[bufnr].last_package_parsed
	end

	state.buffers[bufnr].parse_scheduled = true

	defer_fn(function()
		if not api.nvim_buf_is_valid(bufnr) then
			state.buffers[bufnr].parse_scheduled = false
			return
		end

		local fresh_lines = api.nvim_buf_get_lines(bufnr, 0, -1, false)
		local fresh_content = table_concat(fresh_lines, "\n")

		local ok_decode, parsed = pcall(parse_with_decoder, fresh_content, fresh_lines)
		if ok_decode and parsed then
			local lock_path = utils.find_lock_for_manifest(bufnr, "package")
			local lock_versions = nil
			if lock_path then
				local lock_content = utils.read_file(lock_path)
				lock_versions = parse_lock_file_from_content(lock_content)
			end

			if lock_versions and type(lock_versions) == "table" then
				for name, info in pairs(parsed.dependencies or {}) do
					if lock_versions[name] then
						info.current = lock_versions[name]
					end
				end
				for name, info in pairs(parsed.devDependencies or {}) do
					if lock_versions[name] then
						info.current = lock_versions[name]
					end
				end
			end

			do_parse_and_update(bufnr, parsed, fresh_lines, fresh_content)
		else
			local fb_deps, fb_dev = parse_package_fallback_lines(fresh_lines)
			local conv = {
				dependencies = fb_deps or {},
				devDependencies = fb_dev or {},
				optionalDependencies = {},
				peerDependencies = {},
				overrides = {},
			}

			local lock_path = utils.find_lock_for_manifest(bufnr, "package")
			local lock_versions = nil
			if lock_path then
				local lock_content = utils.read_file(lock_path)
				lock_versions = parse_lock_file_from_content(lock_content)
			end
			if lock_versions and type(lock_versions) == "table" then
				for name in pairs(conv.dependencies or {}) do
					if lock_versions[name] then
						conv.dependencies[name].current = lock_versions[name]
					end
				end
				for name in pairs(conv.devDependencies or {}) do
					if lock_versions[name] then
						conv.devDependencies[name].current = lock_versions[name]
					end
				end
			end

			do_parse_and_update(bufnr, conv, fresh_lines, fresh_content)
		end
	end, 20)

	return state.buffers[bufnr].last_package_parsed
end

M.parse_lock_file_content = parse_lock_file_from_content

M.parse_lock_file_path = function(lock_path)
	local content = utils.read_file(lock_path)
	return parse_lock_file_from_content(content)
end

M.filename = "package.json"
M.manifest_key = "package"

return M
